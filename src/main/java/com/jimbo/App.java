package com.jimbo;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;

import io.reactivex.Completable;
import io.reactivex.Single;
import io.vertx.core.Future;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.sql.SQLOptions;
import io.vertx.reactivex.core.AbstractVerticle;
import io.vertx.reactivex.core.http.HttpServerResponse;
import io.vertx.reactivex.ext.jdbc.JDBCClient;
import io.vertx.reactivex.ext.sql.SQLConnection;
import io.vertx.reactivex.ext.web.Router;
import io.vertx.reactivex.ext.web.RoutingContext;
import io.vertx.reactivex.ext.web.handler.BodyHandler;
import io.vertx.reactivex.ext.web.handler.StaticHandler;

public class App extends AbstractVerticle 
{
	
	private Map readingList = new LinkedHashMap();
	private JDBCClient jdbc;
	
	private void createSomeData() {
		Article article1 = new Article("Jimbotron", "https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing");
		Article article2 = new Article("Reactive Manifesto", "https://www.reactivemanifesto.org");
		readingList.put(article1.getId(), article1);
		readingList.put(article2.getId(), article2);
	}	
	
	private void getAll(RoutingContext rc) {
		connect().compose(this::query).setHandler(ActionHelper.ok(rc));
	}
	
	private void addOne(RoutingContext rc) {
		Article article = rc.getBodyAsJson().mapTo(Article.class);
		connect().compose(connection -> insert(connection, article, true)).setHandler(ActionHelper.created(rc));
	}
	
	private void deleteOne(RoutingContext rc) {
		String id = rc.request().getParam("id");
		connect().compose(connection -> delete(connection, id)).setHandler(ActionHelper.noContent(rc));
	}
	
	private void getOne(RoutingContext rc) {
		String id = rc.pathParam("id");
		connect().compose(connection -> queryOne(connection, id)).setHandler(ActionHelper.ok(rc));
	}
	
	private void updateOne(RoutingContext rc) {
		String id = rc.request().getParam("id");
		Article article = rc.getBodyAsJson().mapTo(Article.class);
		connect().compose(connection -> update(connection, id, article)).setHandler(ActionHelper.noContent(rc));
	}
	
	private Single connect() {
		jdbc.rxGetConnection()
			.map(c -> c.setOptions(new SQLOptions().setAutoGeneratedKeys(true)));
	}
	
	/*
	private Future<SQLConnection> connectNotWorking() {
		Future<SQLConnection> future = Future.future();
		jdbc.getConnection(ar -> 
			future.handle(ar.map(c -> {
					return c.setOptions(new SQLOptions().setAutoGeneratedKeys(true));
			}))
		);
		return future;
	}
	*/
	
	private Single createTableIfNeeded(SQLConnection connection) {
		return vertx.fileSystem().rxReadFile("tables.sql")
		        .map(Buffer::toString)
		        .flatMapCompletable(connection::rxExecute)
		        .toSingleDefault(connection);
	}
	
	private Single createSomeDataIfNone(SQLConnection connection) {
		return connection.rxQuery("SELECT * FROM Articles")
				.flatMap(rs -> {
					if (rs.getResults().isEmpty()) {
						Article article1 = new Article("Jimbotron", "https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing");
						Article article2 = new Article("Reactive Manifesto", "https://www.reactivemanifesto.org");
						return Single.zip(insert(connection, article1, false), insert(connection, article2, false), (a1, a2) -> connection);
					} else {
						return Single.just(connection);
					}
				});
	}
	
	
	private Single<Article> insert(SQLConnection connection, Article article, boolean closeConnection) {
		String sql = "INSERT INTO Articles (title, url) VALUES (?, ?)";
		return connection.rxUpdateWithParams(sql, new JsonArray().add(article.getTitle()).add(article.getUrl()))
				.map(res -> new Article(res.getKeys().getLong(0), article.getTitle(), article.getUrl()))
				.doFinally(() -> {
					if (closeConnection) {
						connection.close();
					}
				});
	}
	
	private Completable createHttpServer(JsonObject config, Router router) {
		Future<Void> future = Future.future();
		vertx.createHttpServer()
			.requestHandler(router::accept)
			.rxListen(config.getInteger("HTTP_PORT", 8080))
			.toCompletable();
	}
	
	private Single<List<Article>> query(SQLConnection connection) {
		return connection.rxQuery("SELECT * FROM articles")
				.map(rs -> rs.getRows().stream().map(Article::new).collect(Collectors.toList()))
				.doFinally(connection::close);
	}
	
	private Single<Article> queryOne(SQLConnection connection, String id) {
		String sql = "SELECT * FROM articles WHERE id = ?";
		return connection.rxQueryWithParams(sql, new JsonArray().add(Integer.valueOf(id)))
						.doFinally(connection::close)
						.map(rs -> {
							List rows = rs.getRows();
							if (rows.size() == 0) {
								throw new NoSuchElementException("No article with id " + id);
							} else {
								JsonObject row = rows.get(0);
								return new Article(row);
							}
						});
	}
	
	private Completable update(SQLConnection connection, String id, Article article) {
		Future<Void> future = Future.future();
		String sql = "UPDATE articles SET title = ?, url = ? WHERE id = ?";
		return connection.rxUpdateWithParams(sql, new JsonArray().add(article.getTitle()).add(article.getUrl()).add(Integer.valueOf(id)))
						.flatMapCompletable(ur -> 
							ur.getUpdated() == 0 ? Completable.error(new NoSuchElementException("No article with id " + id)) : Completable.complete()
						).doFinally(connection::close);
	}
	
	private Completable delete(SQLConnection connection, String id) {
		Future<Void> future = Future.future();
		String sql = "DELETE FROM Articles WHERE id = ?";
		return connection.rxUpdateWithParams(sql, new JsonArray().add(Integer.valueOf(id)))
						.doFinally(connection::close)
						.flatMapCompletable(ur -> 
							ur.getUpdated() == 0 ?
									Completable.error(new NoSuchElementException("No article with id " + id))
									: Completable.complete()
						);
	}
	
    @Override
    public void start(Future fut) {

    	Router router = Router.router(vertx);
    	
    	router.route("/").handler(rc -> {
    		HttpServerResponse response = rc.response();
    		response.putHeader("Content-Type", "text/html")
    				.end("</pre><h1>Hello there... General Kenobi :v</h1><pre>");
    	});
    	
    	router.route("/assets/*").handler(StaticHandler.create("assets"));
    	router.route("/api/articles*").handler(BodyHandler.create());
    	router.get("/api/articles").handler(this::getAll);
    	router.post("/api/articles").handler(this::addOne);
    	router.delete("/api/articles/:id").handler(this::deleteOne);
    	
    	JsonObject config = new JsonObject();
    	config.put("url", "jdbc:mysql://localhost:3306/VertxPOC?useUnicode=true&useJDBCCompliantTimezoneShift=true&useLegacyDatetimeCode=false&serverTimezone=UTC");
    	config.put("user", "root");
    	config.put("password", "");
    	config.put("driver_class", "com.mysql.cj.jdbc.Driver");
    	
    	jdbc = JDBCClient.createShared(vertx, config, "VertxPOC");
    	// createSomeData();
    	connect().compose(connection -> {
    		Future<Void> future = Future.future();
    		createTableIfNeeded(connection).compose(this::createSomeDataIfNone).setHandler(x -> {
    			connection.close();
    			future.handle(x.mapEmpty());
    		});
    		return future;
    	}).compose(v -> createHttpServer(config, router));
    	
    	
    }
}
